/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50524
Source Host           : localhost:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50524
File Encoding         : 65001

Date: 2019-05-07 22:22:19
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article_info`
-- ----------------------------
DROP TABLE IF EXISTS `article_info`;
CREATE TABLE `article_info` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `article_title` varchar(500) DEFAULT NULL,
  `article_content` varchar(4000) DEFAULT NULL,
  `article_img` varchar(1000) DEFAULT NULL,
  `article_recom` varchar(10) DEFAULT NULL,
  `article_time` datetime DEFAULT NULL,
  `article_mark` varchar(10) DEFAULT '1',
  PRIMARY KEY (`article_id`),
  KEY `FK_Reference_1` (`category_id`),
  KEY `FK_Reference_2` (`user_id`),
  CONSTRAINT `FK_Reference_1` FOREIGN KEY (`category_id`) REFERENCES `category_info` (`category_id`),
  CONSTRAINT `FK_Reference_2` FOREIGN KEY (`user_id`) REFERENCES `user_info` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=75 DEFAULT CHARSET=utf8 COMMENT='������Ϣ��';

-- ----------------------------
-- Records of article_info
-- ----------------------------
INSERT INTO `article_info` VALUES ('68', '19', '1', 'SVN和GIT', '<h1>SVN和GIT</h1>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>cmd命令开启svn</h2>\r\n\r\n<p>svnserve -d -r E:\\SVN_WEB\\web</p>\r\n\r\n<h3>git的执行流程</h3>\r\n\r\n<p>工作区-&gt;暂存区-&gt;主库</p>\r\n\r\n<h2>git命令</h2>\r\n\r\n<h3>配置用户名和邮箱</h3>\r\n\r\n<p>git config --global user.name &quot;lgaBug&quot;</p>\r\n\r\n<p>git config --global user.email &quot;<a href=\"mailto:972514286@qq.com\">972514286@qq.com</a>&quot;</p>\r\n\r\n<h3>初始化git</h3>\r\n\r\n<p>git init</p>\r\n\r\n<h3>添加文件</h3>\r\n\r\n<p>git add a.txt</p>\r\n\r\n<h3>提交文件</h3>\r\n\r\n<p>git commit -m &quot;第二次提交2222&quot;（强制要写注释，不然报错）</p>\r\n\r\n<h3>查看状态</h3>\r\n\r\n<p>git status</p>\r\n\r\n<h3>查不同</h3>\r\n\r\n<p>git diff a.txt</p>\r\n\r\n<h3>查看日志</h3>\r\n\r\n<p>git log（可以查看文件修改的信息）</p>\r\n\r\n<p>git reflog</p>\r\n\r\n<h3>返回上一个版本</h3>\r\n\r\n<p>git reset --hard HEAD^（一个&lsquo;^&rsquo;代表一个版本）</p>\r\n\r\n<h3>撤销修改</h3>\r\n\r\n<p>git checkout --a.txt</p>\r\n\r\n<h3>删除文件/撤销删除</h3>\r\n\r\n<p>rm a.txt/git checkout --a.txt</p>\r\n\r\n<p>创建公钥</p>\r\n\r\n<p>ssh-keygen -t rsa -C &quot;<a href=\"mailto:972514286@qq.com\">972514286@qq.com</a>&quot;</p>\r\n\r\n<h3>git连接远程仓库（gitHub）</h3>\r\n\r\n<p>git remote add origin <a href=\"mailto:git@github.com\">git@github.com</a>:lgaBug/bjlemon.git</p>\r\n\r\n<h3>将分支代码传到master分支上</h3>\r\n\r\n<p>git push -u origin master</p>\r\n\r\n<h3>传到master分支时出错了（主要原因是在本地代码中没有README.md文件）</h3>\r\n\r\n<p>先执行</p>\r\n\r\n<p>git pull --rebase origin master</p>\r\n\r\n<p>再上传</p>\r\n\r\n<p>git push -u origin master</p>\r\n\r\n<h3>将远程仓库的项目克隆到本地</h3>\r\n\r\n<p>git clone <a href=\"mailto:git@github.com\">git@github.com</a>:lgaBug/bjlemon.git</p>\r\n\r\n<h3>git和GitHub的联系</h3>\r\n\r\n<p>GitHub是基于git的一个远程仓库</p>\r\n\r\n<h3>SVN和GIT的优缺点比较</h3>\r\n\r\n<p>1．SVN优缺点 优点： 1、 管理方便，逻辑明确，符合一般人思维习惯。 2、 易于管理，集中式服务器更能保证安全性。 3、 代码一致性非常高。 4、 适合开发人数不多的项目开发。 缺点： 1、 服务器压力太大，数据库容量暴增。 2、 如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。 3、 不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</p>\r\n\r\n<p>2．Git优缺点 优点： 1、适合分布式开发，强调个体。 2、公共服务器压力和数据量都不会太大。 3、速度快、灵活。 4、任意两个开发者之间可以很容易的解决冲突。 5、离线工作。 缺点： 1、学习周期相对而言比较长。 2、不符合常规思维。 3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<h2>git笔记</h2>\r\n\r\n<h3>目的：借助gitHub来托管我们的代码</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>', '', '1', '2019-04-29 14:02:18', '1');
INSERT INTO `article_info` VALUES ('69', '19', '1', 'UML类图详解', '<h1>UML类图详解</h1>\r\n\r\n<p>虚线箭头指向依赖；</p>\r\n\r\n<p>实线箭头指向关联；</p>\r\n\r\n<p>虚线三角指向接口；</p>\r\n\r\n<p>实线三角指向父类；</p>\r\n\r\n<p>空心菱形能分离而独立存在，是聚合；</p>\r\n\r\n<p>实心菱形精密关联不可分，是组合；</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1556519894&amp;di=0583abf2a47f67129de12905f336dcb6&amp;src=http://s11.sinaimg.cn/mw690/006hikKrzy7slvzPwSKba&amp;690\" style=\"height:250px; width:400px\" /></p>\r\n\r\n<p>&nbsp;</p>', '', '1', '2019-04-29 14:07:21', '1');
INSERT INTO `article_info` VALUES ('70', '1', '1', 'io流', '<p>io流操作</p>', '', '1', '2019-04-29 14:45:04', '1');
INSERT INTO `article_info` VALUES ('71', '1', '1', '多线程', '<h1>UML类图详解</h1>\r\n\r\n<p>虚线箭头指向依赖；</p>\r\n\r\n<p>实线箭头指向关联；</p>\r\n\r\n<p>虚线三角指向接口；</p>\r\n\r\n<p>实线三角指向父类；</p>\r\n\r\n<p>空心菱形能分离而独立存在，是聚合；</p>\r\n\r\n<p>实心菱形精密关联不可分，是组合；</p>\r\n\r\n<p><span style=\"font-family:monospace\"><img src=\"https://upload-images.jianshu.io/upload_images/2799767-3f16972d7b062110.png?imageMogr2/auto-orient/strip\" style=\"border-bottom-color:initial; border-bottom-style:initial; border-image:initial; border-left-color:transparent; border-left-style:solid; border-right-color:transparent; border-right-style:solid; border-top-color:initial; border-top-style:initial; border-width:0px 4px 0px 2px; box-sizing:border-box; max-width:100%; vertical-align:middle\" />111111111111</span></p>\r\n\r\n<p>打算打算的撒</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>', 'http://localhost:8081/myblog_file/upload/201904291510211494320917455.jpg', '1', '2019-04-29 14:48:20', '1');
INSERT INTO `article_info` VALUES ('72', '20', '1', '888888888', '<p>园艺的传承和创新。陕西展区内，有&ldquo;立体的画、无声的诗&rdquo;美誉的盆景艺术让来宾们赞叹不已。新疆是中国久负盛名的&ldquo;瓜果之乡&rdquo;，新疆展区门口展示的大石榴籽晶莹饱满，紧密相抱，象征着中国各族人民的紧密团结。湖北展区展示的&ldquo;盆景之王&rdquo;对节白蜡体现了中国盆景的独特雄浑。</p>\r\n\r\n<p>　　中国馆按照&ldquo;生生不息，锦绣中华&rdquo;的理念，划分为中国生态文化展区、省区市园艺产业成就展区、园艺类高校及科研单位展区、非物质文化遗产插花艺术展区，是一座会&ldquo;呼吸&rdquo;、有&ldquo;生命&rdquo;的绿色建筑。</p>\r\n\r\n<p style=\"text-align:center\"><img alt=\"１\" src=\"https://p4.img.cctvpic.com/uploadimg/2019/04/29/1556536576491652.jpg\" style=\"border:0px none; margin:0px; padding:0px; width:600px\" /></p>\r\n\r\n<p>　　习近平和贵宾们饶有兴致地观看、交谈。习近平指出，中国馆体现了厚重的地域文化，讲述了美丽的园艺故事，汇聚了中国生态文明建设成果，不仅让我们欣赏到美妙的园艺，更体现了中国与世界追求绿色生活、共享发展成果的理念。</p>', 'http://localhost:8081/myblog_file/upload/20190429230725mmexport1502941635363.jpg', '1', '2019-04-29 23:07:28', '1');
INSERT INTO `article_info` VALUES ('73', '19', '1', 'spring中IOC和AOP的理解', '<p><span style=\"font-size:16px\"><strong>主要分析点：</strong></span></p>\r\n\r\n<p><span style=\"font-size:16px\"><strong>一、Spring开源框架的简介&nbsp;</strong></span></p>\r\n\r\n<p><span style=\"font-size:16px\"><strong>二、Spring下IOC容器和DI(依赖注入Dependency injection)</strong></span></p>\r\n\r\n<p><span style=\"font-size:16px\"><strong>三、Spring下面向切面编程(AOP)和事务管理配置&nbsp;</strong></span></p>\r\n\r\n<p><span style=\"font-size:16px\">&nbsp;</span></p>\r\n\r\n<p><span style=\"font-size:16px\"><strong>一、Spring开源框架的简介&nbsp;</strong></span></p>\r\n\r\n<p><strong>　　</strong>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<span style=\"color:rgb(255, 0, 0)\"><strong>&nbsp;简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</strong></span></p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\"><strong>　</strong>　</span>spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</p>\r\n\r\n<p><img alt=\"\" src=\"https://images2015.cnblogs.com/blog/644566/201609/644566-20160903123450558-100405609.png\" style=\"border:0px; display:block; height:auto; margin-left:auto; margin-right:auto; max-width:900px\" /></p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\"><strong>Spring DAO</strong></span>：Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。</p>\r\n\r\n<p><strong><span style=\"color:rgb(255, 0, 0)\">Spring ORM</span></strong>：Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate的操作 。</p>\r\n\r\n<p><strong><span style=\"color:rgb(255, 0, 0)\">Spring WEB</span></strong>：Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。</p>\r\n\r\n<p><strong><span style=\"color:rgb(255, 0, 0)\">Spring &nbsp;AOP</span></strong>：Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。</p>\r\n\r\n<p><strong><span style=\"color:rgb(255, 0, 0)\">Spring &nbsp; JEE</span></strong>：J2EE开发规范的支持，例如EJB 。</p>\r\n\r\n<p><span style=\"color:rgb(255, 0, 0)\"><strong>Spring Core</strong></span>：提供IOC容器对象的创建和处理依赖对象关系 。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span style=\"font-size:16px\"><strong>二、Spring下IOC容器和DI(依赖注入Dependency injection)</strong></span></p>\r\n\r\n<p>　　<strong><span style=\"color:rgb(255, 0, 0)\">IOC容器</span></strong>：就是具有依赖注入功能的容器，是可以创建对象的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而&quot;控制反转&quot;是指new实例工作不由程序员来做而是交给Spring容器来做。。在Spring中BeanFactory是IOC容器的实际代表者。</p>\r\n\r\n<p>　　<span style=\"color:rgb(255, 0, 0)\"><strong>DI<strong>(依赖注入Dependency injection)</strong></strong></span>&nbsp;：在容器创建对象后，处理对象的依赖关系。</p>\r\n\r\n<p>　　依赖注入spring的注入方式：</p>\r\n\r\n<ul style=\"margin-left:30px\">\r\n	<li>\r\n	<ul style=\"margin-left:30px\">\r\n		<li>\r\n		<ul style=\"margin-left:30px\">\r\n			<li><span style=\"color:rgb(255, 0, 0)\"><strong>set注入方式</strong></span></li>\r\n			<li><span style=\"color:rgb(255, 0, 0)\"><strong>静态工厂注入方式</strong></span></li>\r\n			<li><span style=\"color:rgb(255, 0, 0)\"><strong>构造方法注入方式</strong></span></li>\r\n			<li><span style=\"color:rgb(255, 0, 0)\"><strong>基于注解的方式</strong></span></li>\r\n		</ul>\r\n		</li>\r\n	</ul>\r\n	</li>\r\n</ul>', 'http://localhost:8081/myblog_file/upload/20190504094202mmexport1502941635363.jpg', '1', '2019-05-04 09:50:51', '1');
INSERT INTO `article_info` VALUES ('74', '1', '1', '线程', '<h1>二 面试中关于线程池的 4 连击</h1>\r\n\r\n<h3>2.1 讲一下Java内存模型</h3>\r\n\r\n<p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>\r\n\r\n<p><a href=\"https://camo.githubusercontent.com/5dabf65a6f750c5b767b2e221aaa27eab47d4fa3/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633436656465343432336261323f773d32373326683d31363626663d6a70656726733d37323638\" target=\"_blank\"><img alt=\"数据的不一致\" src=\"https://camo.githubusercontent.com/5dabf65a6f750c5b767b2e221aaa27eab47d4fa3/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633436656465343432336261323f773d32373326683d31363626663d6a70656726733d37323638\" style=\"box-sizing:content-box; max-width:100%\" /></a></p>\r\n\r\n<p>要解决这个问题，就需要把变量声明为&nbsp;volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p>\r\n\r\n<p>说白了，&nbsp;volatile&nbsp;关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>\r\n\r\n<p><a href=\"https://camo.githubusercontent.com/732fc27aae9ea88870e52523712d4902a540524e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633436656465346239663530313f773d34373426683d32333826663d6a70656726733d39393432\" target=\"_blank\"><img alt=\"volatile关键字的可见性\" src=\"https://camo.githubusercontent.com/732fc27aae9ea88870e52523712d4902a540524e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633436656465346239663530313f773d34373426683d32333826663d6a70656726733d39393432\" style=\"box-sizing:content-box; max-width:100%\" /></a></p>\r\n\r\n<h3>2.2 说说 synchronized 关键字和 volatile 关键字的区别</h3>\r\n\r\n<p>synchronized关键字和volatile关键字比较</p>\r\n\r\n<ul>\r\n	<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li>\r\n</ul>', 'http://localhost:8081/myblog_file/upload/20190504105338mmexport1502941635363.jpg', '1', '2019-05-04 10:53:48', '1');
